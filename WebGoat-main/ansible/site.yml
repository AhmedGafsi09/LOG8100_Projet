---
- name: Install and Configure Kubernetes Infrastructure
  hosts: azure-vm
  become: yes
  vars:
    ansible_python_interpreter: /usr/bin/python3
  tasks:
    # Nettoyage des anciens fichiers
    - name: Remove old Kubernetes sources
      file:
        path: /etc/apt/sources.list.d/kubernetes.list
        state: absent

    # Installation des prérequis
    - name: Install dependencies
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsof
        update_cache: yes
        state: present

    # Configuration Docker
    - name: Ensure /usr/share/keyrings exists
      file:
        path: /usr/share/keyrings
        state: directory
        mode: '0755'

    - name: Add Docker GPG key
      get_url:
        url: https://download.docker.com/linux/ubuntu/gpg
        dest: /usr/share/keyrings/docker-archive-keyring.gpg
        mode: '0644'

    - name: Add Docker repository
      shell: |
        echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null

    # Configuration Kubernetes
    - name: Ensure /etc/apt/keyrings exists
      file:
        path: /etc/apt/keyrings
        state: directory
        mode: '0755'

    - name: Add Kubernetes GPG key
      get_url:
        url: https://pkgs.k8s.io/core:/stable:/v1.29/deb/Release.key
        dest: /etc/apt/keyrings/kubernetes-apt-keyring.gpg
        mode: '0644'

    - name: Add Kubernetes repository
      shell: |
        echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.29/deb/ /" | tee /etc/apt/sources.list.d/kubernetes.list > /dev/null

    - name: Update apt and install packages
      apt:
        name:
          - docker-ce
          - kubelet
          - kubeadm
          - kubectl
          - containerd.io
        update_cache: yes
        state: present

    # Configuration système
    - name: Configure Docker daemon
      copy:
        content: |
          {
            "exec-opts": ["native.cgroupdriver=systemd"],
            "log-driver": "json-file",
            "log-opts": {
              "max-size": "100m"
            },
            "storage-driver": "overlay2"
          }
        dest: /etc/docker/daemon.json

    - name: Create Docker directory
      file:
        path: /etc/systemd/system/docker.service.d
        state: directory

    - name: Disable swap
      command: swapoff -a

    # Configure kernel modules
    - name: Configure kernel modules
      modprobe:
        name: "{{ item }}"
        state: present
      with_items:
        - br_netfilter
        - overlay
      ignore_errors: yes

    - name: Set system configurations for Kubernetes networking
      sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: present
        reload: yes
      with_items:
        - { name: 'net.bridge.bridge-nf-call-iptables', value: '1' }
        - { name: 'net.bridge.bridge-nf-call-ip6tables', value: '1' }
        - { name: 'net.ipv4.ip_forward', value: '1' }
      ignore_errors: yes

    # Configuration Firewall
    - name: Configure firewall rules
      ufw:
        rule: allow
        port: "{{ item }}"
        proto: tcp
      loop:
        - 22    # SSH
        - 6443  # Kubernetes API
        - 8080  # WebGoat
        - 9090  # Prometheus
        - 3000  # Grafana
        - 30000
        - 32767  # NodePort range

    # Reset and cleanup existing Kubernetes installation
    - name: Reset Kubernetes cluster
      command: kubeadm reset --force
      ignore_errors: yes

    - name: Remove Kubernetes directories
      file:
        path: "{{ item }}"
        state: absent
      with_items:
        - /etc/kubernetes/manifests
        - /etc/kubernetes/pki
        - /var/lib/kubelet
        - /var/lib/etcd
      ignore_errors: yes

    - name: Kill processes using port 6443
      shell: |
        lsof -ti:6443 | xargs kill -9 || true
      ignore_errors: yes

    # Complete cleanup of Kubernetes
    - name: Complete cleanup of Kubernetes
      shell: |
        systemctl stop kubelet
        systemctl stop docker || true
        systemctl stop containerd
        rm -rf /etc/kubernetes/*
        rm -rf /var/lib/kubelet/*
        rm -rf /var/lib/etcd
        rm -rf /var/run/kubernetes
        rm -rf /var/lib/cni/
        rm -rf /etc/cni/
        ip link delete cni0 || true
        ip link delete flannel.1 || true
        systemctl start containerd
        systemctl start docker || true
      ignore_errors: yes

    - name: Reset crictl
      shell: |
        crictl rm -f $(crictl ps -aq) || true
        crictl rmi -f $(crictl images -q) || true
      ignore_errors: yes

    # Stop and cleanup services
    - name: Stop all services
      systemd:
        name: "{{ item }}"
        state: stopped
      with_items:
        - kubelet
        - docker
        - containerd
      ignore_errors: yes

    - name: Clean up network configurations
      shell: |
        ip link delete docker0 || true
        ip link delete cni0 || true
        ip link delete flannel.1 || true
        rm -rf /var/lib/cni/
        rm -rf /etc/cni/
      ignore_errors: yes

    - name: Clean containerd state
      file:
        path: "{{ item }}"
        state: absent
      with_items:
        - /var/run/containerd
        - /var/lib/containerd
        - /etc/containerd/config.toml
      ignore_errors: yes

    - name: Reconfigure containerd
      shell: |
        mkdir -p /etc/containerd
        containerd config default | tee /etc/containerd/config.toml
        sed -i 's/SystemdCgroup \= false/SystemdCgroup \= true/g' /etc/containerd/config.toml

    - name: Restart containerd
      systemd:
        name: containerd
        state: restarted
        daemon_reload: yes
        enabled: yes

    - name: Wait for containerd socket
      wait_for:
        path: /run/containerd/containerd.sock
        state: present
        timeout: 30

    - name: Verify containerd status
      shell: ctr version
      register: containerd_status
      ignore_errors: yes

    - name: Show containerd status
      debug:
        var: containerd_status.stdout_lines

    # Restart other services
    - name: Restart Docker
      systemd:
        name: docker
        state: restarted
        daemon_reload: yes
        enabled: yes

    - name: Start kubelet
      systemd:
        name: kubelet
        state: started
        enabled: yes
      ignore_errors: yes

    # Initialize Kubernetes
    - name: Initialize Kubernetes cluster
      shell: |
        kubeadm init \
        --pod-network-cidr=192.168.0.0/16 \
        --upload-certs \
        --ignore-preflight-errors=all \
        --v=5 \
        --cri-socket unix:///run/containerd/containerd.sock \
        --skip-phases=addon/kube-proxy \
        2>&1 | tee /var/log/kubeadm-init.log
      register: kubeadm_init
      ignore_errors: yes

    - name: Get init logs
      shell: |
        echo "=== Kubeadm Init Log ==="
        cat /var/log/kubeadm-init.log
        echo "=== Kubelet Status ==="
        systemctl status kubelet
        echo "=== Kubelet Logs ==="
        journalctl -u kubelet --no-pager | tail -n 50
      register: init_logs
      ignore_errors: yes

    - name: Display init logs
      debug:
        var: init_logs.stdout_lines

    # Verify control plane components
    - name: Verify control plane components
      shell: |
        mkdir -p /tmp/k8s-debug
        echo "=== Static Pod Manifests ==="
        ls -l /etc/kubernetes/manifests/
        echo "=== Certificates ==="
        ls -l /etc/kubernetes/pki/
        echo "=== Container Status ==="
        crictl ps -a
        echo "=== Container Logs ==="
        for pod in $(crictl ps -a -q); do
          echo "=== Logs for $pod ==="
          crictl logs $pod || true
        done
      register: verification
      ignore_errors: yes

    - name: Display verification
      debug:
        var: verification.stdout_lines

    - name: Wait for API server socket
      wait_for:
        path: /var/run/kubernetes/apiserver.sock
        timeout: 300
      ignore_errors: yes

    # Check API server status
    - name: Check API server status
      shell: |
        for i in {1..30}; do
          if nc -z localhost 6443; then
            echo "API server is listening on port 6443"
            exit 0
          fi
          echo "Waiting for API server... attempt $i"
          sleep 10
        done
        exit 1
      register: api_check
      ignore_errors: yes

    - name: Remove master node taint
      command: kubectl taint nodes --all node-role.kubernetes.io/control-plane-
      become_user: azureuser
      ignore_errors: yes

    - name: Verify cluster info
      command: kubectl cluster-info
      become_user: azureuser
      register: cluster_info
      retries: 10
      delay: 10
      until: cluster_info.rc == 0

    - name: Display cluster info
      debug:
        var: cluster_info.stdout_lines

    # Install Calico CNI
    - name: Download Calico manifest
      get_url:
        url: https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/calico.yaml
        dest: /home/azureuser/calico.yaml
      become_user: azureuser

    - name: Install Calico manifest locally
      command: kubectl apply -f /home/azureuser/calico.yaml --validate=false
      become_user: azureuser
      retries: 3
      delay: 10

    - name: Wait for Calico pods
      shell: |
        kubectl -n kube-system wait --for=condition=Ready pods -l k8s-app=calico-node --timeout=300s
        kubectl -n kube-system wait --for=condition=Ready pods -l k8s-app=calico-kube-controllers --timeout=300s
      become_user: azureuser
      register: calico_pods
      retries: 10
      delay: 30
      until: calico_pods.rc == 0

    # Install Helm
    - name: Download and install Helm
      shell: |
        curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
        chmod 700 get_helm.sh
        ./get_helm.sh

    # Create namespaces
    - name: Create namespaces
      command: "{{ item }}"
      with_items:
        - kubectl create namespace webgoat
        - kubectl create namespace monitoring
      ignore_errors: yes
      become_user: azureuser

    # Deploy WebGoat
    - name: Deploy WebGoat resources
      command: kubectl apply -f {{ item }}
      with_items:
        - manifests/resource-quota.yml
        - manifests/service-account.yml
        - manifests/network-policy.yml
        - manifests/deployment.yml
        - manifests/service.yml
      become_user: azureuser

    # Install Prometheus and Grafana
    - name: Add Helm repositories
      command: "{{ item }}"
      with_items:
        - helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
        - helm repo add grafana https://grafana.github.io/helm-charts
        - helm repo update
      become_user: azureuser

    - name: Install Prometheus
      command: >
        helm install prometheus prometheus-community/kube-prometheus-stack
        --namespace monitoring
        -f ../kubernetes/prometheus-values.yaml
      become_user: azureuser
      ignore_errors: yes

    - name: Install Grafana
      command: >
        helm install grafana grafana/grafana
        --namespace monitoring
        -f ../kubernetes/grafana-values.yaml
      become_user: azureuser
      ignore_errors: yes

    # Verify deployment
    - name: Wait for pods
      shell: |
        kubectl wait --for=condition=Ready pods --all -n webgoat --timeout=300s
        kubectl wait --for=condition=Ready pods --all -n monitoring --timeout=300s
      become_user: azureuser
      ignore_errors: yes

    - name: Get deployment status
      shell: |
        echo "=== Nodes ==="
        kubectl get nodes
        echo "=== Pods ==="
        kubectl get pods --all-namespaces
        echo "=== Services ==="
        kubectl get services --all-namespaces
      register: deployment_status
      become_user: azureuser

    - name: Show deployment status
      debug:
        var: deployment_status.stdout_lines

    - name: Get service URLs
      shell: |
        echo "WebGoat URL: http://$(curl -s ifconfig.me):$(kubectl get svc -n webgoat webgoat -o jsonpath='{.spec.ports[0].nodePort}')"
        echo "Grafana URL: http://$(curl -s ifconfig.me):$(kubectl get svc -n monitoring grafana -o jsonpath='{.spec.ports[0].nodePort}')"
      register: service_urls
      become_user: azureuser
      ignore_errors: yes

    - name: Display service URLs
      debug:
        var: service_urls.stdout_lines
