---
- name: Install and Configure Kubernetes Infrastructure
  hosts: azure-vm
  become: yes
  vars:
    ansible_python_interpreter: /usr/bin/python3
  tasks:
    # Nettoyage des anciens fichiers
    - name: Remove old Kubernetes sources
      file:
        path: /etc/apt/sources.list.d/kubernetes.list
        state: absent

    # Installation des prérequis
    - name: Install dependencies
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsof
        update_cache: yes
        state: present

    # Configuration Docker
    - name: Ensure /usr/share/keyrings exists
      file:
        path: /usr/share/keyrings
        state: directory
        mode: '0755'

    - name: Add Docker GPG key
      get_url:
        url: https://download.docker.com/linux/ubuntu/gpg
        dest: /usr/share/keyrings/docker-archive-keyring.gpg
        mode: '0644'

    - name: Add Docker repository
      shell: |
        echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null

    # Configuration Kubernetes
    - name: Ensure /etc/apt/keyrings exists
      file:
        path: /etc/apt/keyrings
        state: directory
        mode: '0755'

    - name: Add Kubernetes GPG key
      get_url:
        url: https://pkgs.k8s.io/core:/stable:/v1.29/deb/Release.key
        dest: /etc/apt/keyrings/kubernetes-apt-keyring.gpg
        mode: '0644'

    - name: Add Kubernetes repository
      shell: |
        echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.29/deb/ /" | tee /etc/apt/sources.list.d/kubernetes.list > /dev/null

    - name: Update apt and install packages
      apt:
        name:
          - docker-ce
          - kubelet
          - kubeadm
          - kubectl
          - containerd.io
        update_cache: yes
        state: present

    # Configuration système
    - name: Configure Docker daemon
      copy:
        content: |
          {
            "exec-opts": ["native.cgroupdriver=systemd"],
            "log-driver": "json-file",
            "log-opts": {
              "max-size": "100m"
            },
            "storage-driver": "overlay2"
          }
        dest: /etc/docker/daemon.json

    - name: Create Docker directory
      file:
        path: /etc/systemd/system/docker.service.d
        state: directory

    - name: Disable swap
      command: swapoff -a

    # Configure kernel modules
    - name: Configure kernel modules
      modprobe:
        name: "{{ item }}"
        state: present
      with_items:
        - br_netfilter
        - overlay
      ignore_errors: yes

    - name: Set system configurations for Kubernetes networking
      sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: present
        reload: yes
      with_items:
        - { name: 'net.bridge.bridge-nf-call-iptables', value: '1' }
        - { name: 'net.bridge.bridge-nf-call-ip6tables', value: '1' }
        - { name: 'net.ipv4.ip_forward', value: '1' }
      ignore_errors: yes

    # Configuration Firewall
    - name: Configure firewall rules
      ufw:
        rule: allow
        port: "{{ item }}"
        proto: tcp
      loop:
        - 22    # SSH
        - 6443  # Kubernetes API
        - 8080  # WebGoat
        - 9090  # Prometheus
        - 3000  # Grafana
        - 30000
        - 32767  # NodePort range

    # Reset and cleanup existing Kubernetes installation
    - name: Reset Kubernetes cluster
      command: kubeadm reset --force
      ignore_errors: yes

    - name: Remove Kubernetes directories
      file:
        path: "{{ item }}"
        state: absent
      with_items:
        - /etc/kubernetes/manifests
        - /etc/kubernetes/pki
        - /var/lib/kubelet
        - /var/lib/etcd
      ignore_errors: yes

    - name: Kill processes using port 6443
      shell: |
        lsof -ti:6443 | xargs kill -9 || true
      ignore_errors: yes

    # Complete cleanup of Kubernetes
    - name: Complete cleanup of Kubernetes
      shell: |
        systemctl stop kubelet
        systemctl stop docker || true
        systemctl stop containerd
        rm -rf /etc/kubernetes/*
        rm -rf /var/lib/kubelet/*
        rm -rf /var/lib/etcd
        rm -rf /var/run/kubernetes
        rm -rf /var/lib/cni/
        rm -rf /etc/cni/
        ip link delete cni0 || true
        ip link delete flannel.1 || true
        systemctl start containerd
        systemctl start docker || true
      ignore_errors: yes

    - name: Reset crictl
      shell: |
        crictl rm -f $(crictl ps -aq) || true
        crictl rmi -f $(crictl images -q) || true
      ignore_errors: yes

    # Stop and cleanup services
    - name: Stop all services
      systemd:
        name: "{{ item }}"
        state: stopped
      with_items:
        - kubelet
        - docker
        - containerd
      ignore_errors: yes

    - name: Clean up network configurations
      shell: |
        ip link delete docker0 || true
        ip link delete cni0 || true
        ip link delete flannel.1 || true
        rm -rf /var/lib/cni/
        rm -rf /etc/cni/
      ignore_errors: yes

    - name: Clean containerd state
      file:
        path: "{{ item }}"
        state: absent
      with_items:
        - /var/run/containerd
        - /var/lib/containerd
        - /etc/containerd/config.toml
      ignore_errors: yes

    - name: Configure containerd
      shell: |
        cat > /etc/containerd/config.toml << EOF
        version = 2
        root = "/var/lib/containerd"
        state = "/run/containerd"
        
        [grpc]
          address = "/run/containerd/containerd.sock"
          uid = 0
          gid = 0
        
        [plugins."io.containerd.grpc.v1.cri"]
          sandbox_image = "registry.k8s.io/pause:3.9"
          [plugins."io.containerd.grpc.v1.cri".containerd]
            default_runtime_name = "runc"
            [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
              runtime_type = "io.containerd.runc.v2"
              [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]
                SystemdCgroup = true
        EOF
        
        systemctl restart containerd
        systemctl restart kubelet
      ignore_errors: yes

    - name: Restart containerd
      systemd:
        name: containerd
        state: restarted
        daemon_reload: yes
        enabled: yes

    - name: Wait for containerd socket
      wait_for:
        path: /run/containerd/containerd.sock
        state: present
        timeout: 30

    - name: Verify containerd status
      shell: ctr version
      register: containerd_status
      ignore_errors: yes

    - name: Show containerd status
      debug:
        var: containerd_status.stdout_lines

    # Restart other services
    - name: Restart Docker
      systemd:
        name: docker
        state: restarted
        daemon_reload: yes
        enabled: yes

    - name: Start kubelet
      systemd:
        name: kubelet
        state: started
        enabled: yes
      ignore_errors: yes

    # Pre-pull required images
    - name: Pre-pull required images
      shell: |
        kubeadm config images pull --v=5
      register: image_pull
      ignore_errors: yes

    - name: Display image pull results
      debug:
        var: image_pull.stdout_lines

    # Initialize Kubernetes cluster
    - name: Initialize Kubernetes cluster
      shell: |
        kubeadm init \
          --pod-network-cidr=192.168.0.0/16 \
          --upload-certs \
          --ignore-preflight-errors=all \
          --v=5 \
          --cri-socket=unix:///run/containerd/containerd.sock \
          --control-plane-endpoint="$(hostname):6443" \
          > /var/log/kubeadm-init.log 2>&1
      register: kubeadm_init
      ignore_errors: yes

    - name: Show init log
      shell: |
        echo "=== kubeadm init log ==="
        cat /var/log/kubeadm-init.log
        echo "=== kubelet status ==="
        systemctl status kubelet
        echo "=== kubelet logs ==="
        journalctl -xeu kubelet --no-pager | tail -n 50
      register: init_results
      ignore_errors: yes

    - name: Display init results
      debug:
        var: init_results.stdout_lines

    - name: Wait for kubelet to settle
      shell: |
        # Wait for kubelet to be running
        for i in $(seq 1 30); do
          if systemctl is-active kubelet > /dev/null; then
            echo "Kubelet is running"
            break
          fi
          echo "Waiting for kubelet... attempt $i"
          sleep 5
        done
        
        # Show systemd status
        systemctl status kubelet --no-pager
      register: kubelet_status
      ignore_errors: yes

    - name: Display kubelet status
      debug:
        var: kubelet_status.stdout_lines

    # Verify control plane components
    - name: Verify control plane components
      shell: |
        mkdir -p /tmp/k8s-debug
        echo "=== Static Pod Manifests ==="
        ls -l /etc/kubernetes/manifests/
        echo "=== Certificates ==="
        ls -l /etc/kubernetes/pki/
        echo "=== Container Status ==="
        crictl ps -a
        echo "=== Container Logs ==="
        for pod in $(crictl ps -a -q); do
          echo "=== Logs for $pod ==="
          crictl logs $pod || true
        done
      register: verification
      ignore_errors: yes

    - name: Display verification
      debug:
        var: verification.stdout_lines

    - name: Wait for API server socket
      wait_for:
        path: /var/run/kubernetes/apiserver.sock
        timeout: 300
      ignore_errors: yes

    # Get etcd and apiserver logs
    - name: Get detailed container logs
      shell: |
        echo "=== etcd container logs ==="
        for container in $(crictl ps -a | grep etcd | awk '{print $1}'); do
          echo "Container ID: $container"
          crictl inspect $container
          crictl logs $container
        done

        echo "=== API server container logs ==="
        for container in $(crictl ps -a | grep kube-apiserver | awk '{print $1}'); do
          echo "Container ID: $container"
          crictl inspect $container
